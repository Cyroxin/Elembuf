
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>buffer</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">buffer</h1>
        <section id="module_content"><section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    <a href="https://cyroxin.github.io/Elembuf/source.html">&lt;</a>

  </p>
</div>

</section>
<section class="section ddoc_module_members_section">
  <div class="ddoc_module_members">
    <ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Buffer" id="Buffer"><code class="code">Buffer</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Buffer"></span>struct <code class="code">Buffer</code>(InternalType = char, bool Threaded = false);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Dynamic buffer with a maximum length of one memory page which can take up to <a href="#Buffer.max">max</a> elements.
 Takes an advantage of the system's memory mirroring capabillities to
 create a memory loop so that memory copying wont be necessary.
 The buffer may be manipulated normally as if it were a T[].

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">InternalType</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Element type which the buffer will hold.
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">Threaded</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Create a background thread to fill the buffer. Makes it no longer directly castable to T[].
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_bugs">
  <h4>Bugs</h4>
  <p class="para">
    
<ul><li>Setting the buffer to anything else than memory that the buffer owns will cause an exception.</li>
<li>Copying will cause the original buffer to deallocate when out of scope. Instead pass slices, use a module-level global variable or do not deallocate instances.</li>
<li><b style="color:blue;">[WINDOWS]</b> Additional instances will become slices of the original buffer.</li>
</ul>
 <br>
<hr />
  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    Construction

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> buffer;

<span class="keyword">scope</span> bufchar = <span class="psymbol">Buffer</span>!()(); <span class="comment">// Create buffer, defaults to char[]
</span><span class="keyword">assert</span>(bufchar == <span class="string_literal">""</span>);

<span class="keyword">scope</span> <span class="psymbol">Buffer</span>!<span class="keyword">int</span> bufint = <span class="psymbol">Buffer</span>!<span class="keyword">int</span>(); <span class="comment">// Create buffer of int[]
</span><span class="keyword">assert</span>(bufint == []);

<span class="comment">// With fill, internally calls constructor and then fill()
</span>
<span class="keyword">scope</span> <span class="psymbol">Buffer</span>!<span class="keyword">char</span> fakebufchar = <span class="string_literal">"Hello World!"</span>;
<span class="keyword">assert</span>(fakebufchar.avail == fakebufchar.max - <span class="string_literal">"Hello World!"</span>.length);

<span class="keyword">scope</span> <span class="psymbol">Buffer</span>!<span class="keyword">int</span> fakebufint = [1,2,3,4,5];
<span class="keyword">assert</span>(fakebufint.avail == fakebufint.max - ([1,2,3,4,5]).length);		

<span class="keyword">scope</span> <span class="psymbol">Buffer</span>!<span class="keyword">char</span> fakebufcharlong = <span class="psymbol">Buffer</span>!<span class="keyword">char</span>(<span class="string_literal">"Hello World!"</span>);
<span class="keyword">assert</span>(fakebufcharlong.avail == fakebufcharlong.max - <span class="string_literal">"Hello World!"</span>.length);

<span class="keyword">scope</span> <span class="psymbol">Buffer</span>!<span class="keyword">int</span> fakebufintlong = <span class="psymbol">Buffer</span>!<span class="keyword">int</span>([1,2,3,4,5]);
<span class="keyword">assert</span>(fakebufintlong.avail == fakebufintlong.max - ([1,2,3,4,5]).length);
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div><div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    Usage

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">// [BASIC]
</span><span class="keyword">import</span> buffer,source;

<span class="psymbol">Buffer</span>!<span class="keyword">char</span> buf = <span class="psymbol">Buffer</span>!()();

<span class="comment">// Sources could also directly use a delegate lambda =&gt; "(char[] x){return numberOfElementsWrittenToXArray}"
</span><span class="keyword">auto</span> srcworld = <span class="string_literal">" World"</span>.ArraySource!<span class="keyword">char</span>;
<span class="keyword">auto</span> srcbuf = <span class="string_literal">"buf"</span>.ArraySource!<span class="keyword">char</span>;

buf.fill(<span class="string_literal">"Hello"</span>); <span class="comment">// Old method of filling without abstraction
</span><span class="keyword">assert</span>(buf == <span class="string_literal">"Hello"</span>);

buf.fill(srcworld); <span class="comment">// Old method of filling with abstraction
</span><span class="keyword">assert</span>(buf == <span class="string_literal">"Hello World"</span>);

buf &lt;&lt; <span class="string_literal">" -Elem"</span>; <span class="comment">// Modern way of filling, equivalent to .fill
</span><span class="keyword">assert</span>(buf == <span class="string_literal">"Hello World -Elem"</span>);

buf &lt;&lt;= srcbuf; <span class="comment">// Modern way of filling, equivalent to .fill!true
</span><span class="keyword">assert</span>(buf == <span class="string_literal">"Hello World -Elembuf"</span>);

buf.length = 0; <span class="comment">// Remove all items. O(1)
</span><span class="keyword">assert</span>(buf == <span class="string_literal">""</span> &amp;&amp; buf.ptr[0..5] == <span class="string_literal">"Hello"</span>); <span class="comment">// Elements are not truly gone until overwritten.
</span>
<span class="comment">// Sources should not output anything as they are used. Reusable sources can be implemented with a lambda.
</span>buf &lt;&lt; srcworld;
buf &lt;&lt;= srcbuf;

<span class="keyword">assert</span>(buf == <span class="string_literal">""</span>); <span class="comment">// Previous source reads did not output to buf as they were empty.
</span></code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div><div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    Optimization

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">// [INTERMEDIATE]
</span><span class="comment">// Removing all overhead from fill by using compile-time guarantees by counting increments to slice pointer.  
</span>
<span class="keyword">import</span> buffer;

<span class="keyword">char</span>[] data(size_t characters) <span class="keyword">pure</span> <span class="keyword">nothrow</span> @trusted
{
	<span class="keyword">char</span>[] arr;
	arr.reserve(characters);
	arr.length = characters;

	arr[] = ' ';
	<span class="keyword">return</span> arr;
}

<span class="psymbol">Buffer</span>!<span class="keyword">char</span> buf = <span class="psymbol">Buffer</span>!()(); <span class="comment">/// There is (max * 2 - 1) of free pops after construction and max after fill.
</span>
<span class="comment">// max * 2 - 1 pops left
</span>
buf &lt;&lt;= data(buf.max); <span class="comment">// '=' signifies unsafe fill. it is proven safe in this example
</span>buf = buf[$ .. $]; <span class="comment">// Do work
</span>
<span class="keyword">assert</span>(buf == <span class="string_literal">""</span>);

<span class="comment">// max - 1 pops left
</span>
<span class="keyword">assert</span>(buf.avail - 1 == buf.max - 1);

buf &lt;&lt;= data(buf.avail - 1); <span class="comment">// In this case, (avail - 1) == (max - 1)
</span>buf = buf[$ .. $]; <span class="comment">// We've now used our pops =&gt; 0 pops available
</span>
<span class="keyword">assert</span>(buf == <span class="string_literal">""</span>);

<span class="comment">// Out of free pops after construction. Next pop to an unsafely filled buffer will cause an exception eventually.
</span><span class="comment">// From this point on, every safe fill will set max to available pops
</span>
buf &lt;&lt; data(0); <span class="comment">// Safety is now reinstated by the buffer. =&gt; Max pops available
</span><span class="keyword">assert</span>(buf == <span class="string_literal">""</span>); <span class="comment">// While there are max pops available, there is nothing to pop
</span>
buf &lt;&lt;= <span class="string_literal">"a"</span>;
buf &lt;&lt;= data(buf.max-1);

<span class="keyword">assert</span>(buf[0] == 'a');
buf = buf [$..$]; <span class="comment">// We've now used our pops =&gt; 0 pops available
</span>
<span class="comment">// Note: Changing length does not add to the pop count.
</span>
buf &lt;&lt; data(buf.max);
buf.length = buf.max/2; <span class="comment">// Setting length is @nogc in a buffer
</span>buf &lt;&lt;= data(buf.max/2); <span class="comment">// We still have max pops.
</span>
buf = buf [$..$]; <span class="comment">// We've now used our pops =&gt; 0 pops available
</span></code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div><div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    Properties

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">// [ADVANCED]
</span><span class="comment">// This is a example of how to mirror data to create new array item orders using a mirror.
</span><span class="comment">// X will represent max/2 amount of data that is viewed by the buffer and O data that is not viewed, but still owned by it.
</span><span class="comment">// | will represent the mirror or page boundary. Left side of | is reality and right side is the mirror image.
</span>
<span class="comment">// OO|OO =&gt; First O is identical to third O &amp; Second O is identical to fourth O.
</span><span class="comment">// XX|OO Length is max.
</span><span class="comment">// OX|OO max/2 is popped
</span><span class="comment">// OX|XO Length is max =&gt; Data order is now reversed, First is the second half of max/2 and then is the first half.
</span><span class="comment">// Example on how to do this:
</span>
<span class="keyword">import</span> buffer;

<span class="psymbol">Buffer</span>!<span class="keyword">char</span> buf = <span class="psymbol">Buffer</span>!()(); <span class="comment">// OO|OO
</span>buf.length = buf.max; <span class="comment">// XX|OO
</span>
buf = buf[buf.max/2..$]; <span class="comment">// OX|OO
</span>buf[] = 'a'; <span class="comment">// Set all in X to 'a' =&gt; 0a|0a
</span>buf.length = buf.max; <span class="comment">// OX|XO
</span>buf[$/2..$] = 'b'; <span class="comment">// Set all X right side of | to 'b' =&gt; ba|ba
</span>
<span class="comment">// The buffer is in a mirror |, half of the buffer is in the first page and half in second page. OX|XO
</span><span class="comment">// It is possible to invert the buffer so, that data starts with 'b' instead of 'a'.
</span><span class="comment">// Data is identical left and right side of the mirror, thus inversion can be sought from the mirror.
</span>
<span class="comment">// a, OX|XO
</span>buf = (buf.ptr - buf.max/2)[0..buf.max]; <span class="comment">// XX|OO
</span><span class="keyword">assert</span>(buf[0] == 'b' &amp;&amp; buf[$/2+1] == 'a'); <span class="comment">// Opt: In this case $ could be buf.max as well.
</span>
<span class="comment">// b, XX|OO
</span>buf = (buf.ptr + buf.max)[0..buf.length]; <span class="comment">// OO|XX
</span><span class="keyword">assert</span>(buf[0] == 'b' &amp;&amp; buf[$/2+1] == 'a'); <span class="comment">// As seen, both sides are identical. Both pages contain a's and b's.
</span></code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div><div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    Reusage

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">// [EXPERT]
</span><span class="comment">// Working with multiple buffers and sharing buffers. 
</span>
<span class="keyword">import</span> buffer;

<span class="comment">/* Multiple buffers */</span>
{
	<span class="keyword">scope</span> buf = <span class="psymbol">Buffer</span>!()();
	<span class="keyword">scope</span> bufslice = buf; <span class="comment">// Slice of buf.
</span>
	buf.length = 1;
	bufslice.length = 1;

	buf[0] = 'a';
	<span class="keyword">assert</span>(bufslice[0] == 'a');
} <span class="comment">// deallocation occurs here due to scope.
</span>
<span class="comment">// Let's say that another buffer is allocated.
</span><span class="comment">// If the earlier examples were not scope and not encircled in curly brackets, a new buffer, "bufn", would have seen an error. 
</span>
<span class="psymbol">Buffer</span>!<span class="keyword">char</span> bufn = <span class="psymbol">Buffer</span>!()();

<span class="comment">// The reason is that the earlier buffers would have deallocated during this comment, rather than during the closing squirly brackets.
</span>
<span class="comment">// This is fine on all other operating systems except on Windows.
</span><span class="comment">// On Windows, there can only be one buffer and all new constructions, Buffer!()(), will be slices of the original.
</span><span class="comment">// If bufn fills memory after it is deallocated by buf or bufslice, it breaks on windows. This is why we use scope and squirly brackets to make this work.
</span>
bufn &lt;&lt; <span class="string_literal">"Hello world!"</span>; <span class="comment">// As said, this would have caused an error if not for scope.
</span>
<span class="comment">// NOTE: Had bufslice been passed to a function, it would have deallocated buf in addition to bufslice. Thus you cannot pass buffer slices to functions.
</span>
<span class="comment">/* Sharing buffers */</span>

<span class="comment">// Method 1: Normal slices
</span>{
	<span class="keyword">scope</span> buf = <span class="psymbol">Buffer</span>!()();
	<span class="keyword">char</span>[] slice = buf; <span class="comment">// While buffer slices deallocate original, normal slices do not.
</span>
	buf &lt;&lt; slice; <span class="comment">// We can pass a normal slice to a function. A simple cast(char[]) would've worked as well.
</span>
} <span class="comment">// deallocation occurs here due to scope.
</span>
<span class="comment">// Method 2: Public shared buffers
</span>{
	<span class="comment">// The idea is that you can define a global in module scope and make it deallocate only when the program exits. 
</span>	<span class="comment">// You can also make it shared so other threads can take advantage of it as well. You can do it like this:
</span>
	<span class="comment">/* public */</span> <span class="keyword">shared</span> <span class="psymbol">Buffer</span>!() bufs = <span class="keyword">cast</span>(<span class="keyword">shared</span>) <span class="psymbol">Buffer</span>!()(); 
	<span class="keyword">assert</span>(bufs == <span class="keyword">cast</span>(<span class="keyword">shared</span>) []);
}
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Buffer.max" id="Buffer.max"><code class="code">max</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Buffer.max"></span>enum auto <code class="code">max</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the maximum size of the buffer depending on the size of T.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Buffer.fill" id="Buffer.fill"><code class="code">fill</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Buffer.fill"></span>void <code class="code">fill</code>(bool isSafe = false)(scope const T[] <code class="code">arr</code>) if (!Threaded);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
     Extends the buffer with new data directly from an array or buffer masquerading as an array.
 In this variant of <code class="code">fill</code>, consuming the source is not needed nor is returning lifetime.
 The following must be <code class="code">true</code> on function call:

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">assert</span>(buffer.avail &gt;= <span class="param">arr</span>.length);
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">isSafe</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Safety guarantee optimization, set to <code class="code">true</code> if pop count after last unsafe <code class="code">fill</code> is less than max or less than 2 times max after construction.
 Safety guaranteed calls can be stacked, but a singular call is more efficient. Removes all overhead from the buffer compared to a normal array.
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">T[] <code class="code">arr</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Array source that is slicable and has a length property.
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Buffer.fill" id="Buffer.fill"><code class="code">fill</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Buffer.fill.2"></span>void <code class="code">fill</code>(bool isSafe = false, Source)(ref Source <code class="code">source</code>) if (!Threaded);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Extends the buffer with new data from an abstacted reference <code class="code">source</code>.

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">isSafe</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Safety guarantee optimization, set to <code class="code">true</code> if pop count after last unsafe <code class="code">fill</code> is less or equal to max or less than 2 times max after construction.
 Safety guaranteed calls can be stacked, but a singular call is more efficient. Removes all overhead from the buffer compared to a normal array.
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">Source <code class="code">source</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Object that implements the <a href="https://cyroxin.github.io/Elembuf/source.html">docs/source</a> src interface.
 A <code class="code">source</code> is valid if it implements  <code class="code"><span class="color_blue">size_t delegate</span>(T[]) src()</code> function, where T[] is the area to be filled.
 The src function returns the <code class="code">source</code> delegate/function, which returns the amount of elements written to the given T[].
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_see_also">
  <h4>See Also</h4>
  <p class="para">
    Source examples at <a href="https://cyroxin.github.io/Elembuf/source.html">docs/source</a>
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Buffer.fill" id="Buffer.fill"><code class="code">fill</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Buffer.fill.3"></span>@property void <code class="code">fill</code>()(scope const size_t delegate(T[]) <code class="code">source</code>) if (Threaded);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Sets the <code class="code">source</code> which the buffer uses to <code class="code">fill</code> itself. A subsequent call without params is needed
 to query the background thread for new data.

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">size_t delegate(T[]) <code class="code">source</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Object that implements the <a href="https://cyroxin.github.io/Elembuf/source.html">docs/source</a> src interface.
 A <code class="code">source</code> is valid if it implements <code class="code"><span class="color_blue">size_t delegate</span>(T[]) src()</code> function, where T[] is the area to be filled.
 The src function returns the <code class="code">source</code> delegate/function, which returns the amount of elements written to the given T[].
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_see_also">
  <h4>See Also</h4>
  <p class="para">
    Source examples at <a href="https://cyroxin.github.io/Elembuf/source.html">docs/source</a>
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#Buffer.fill" id="Buffer.fill"><code class="code">fill</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="Buffer.fill.4"></span>nothrow @nogc void <code class="code">fill</code>(bool isSafe = false)() if (Threaded);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Extends buffer by the amount of data read by the buffer and orders buffer to read additional data from the same source.

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">isSafe</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Safety guarantee optimization, set to <code class="code">true</code> if pop count after last unsafe <code class="code">fill</code> is less or equal to max or less than 2 times max after construction.
 Safety guaranteed calls can be stacked, but a singular call is more efficient.
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>

</section>

</div>

</li>
</ul>

</div>

</li>
</ul>
  </div>
</section>
</section>
      </article>
    </div>
  </body>
</html>
