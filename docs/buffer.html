
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>buffer</title>
    <style type="text/css" media="screen">
      html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p,
      blockquote, pre, a, abbr, address, cite, code, del, dfn, em, figure,
      img, ins, kbd, q, s, samp, small, strong, sub, sup, var, b, u, i, dl,
      dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption,
      tbody, tfoot, thead, tr, th, td {
        background: transparent none repeat scroll 0 0;
        border: 0 none;
        font-size: 100%;
        margin: 0;
        outline: 0 none;
        padding: 0;
        vertical-align: baseline;
      }

      h1 { font-size: 200%; }
      h2 { font-size: 160%; }
      h3 { font-size: 120%; }
      h4 { font-size: 100%; }
      h5 { font-size: 80%; }
      h6 { font-size: 80%; font-weight: normal; }

      ul, ol {
        margin: 1.4em 0;
      }
      ul ul, ol ol, ul ol, ol ul {
        margin-top: 0;
        margin-bottom: 0;
      }
      ul, ol {
        margin-left: 2.8em;
      }

      ol {
        list-style: decimal;
      }
      ol ol {
        list-style: lower-alpha;
      }
      ol ol ol {
        list-style: lower-roman;
      }
      ol ol ol ol {
        list-style: decimal;
      }

      blockquote {
        margin: 0.1em;
        margin-left: 1em;
        border-left: 2px solid #cccccc;
        padding-left: 0.7em;
      }

      .color_red { color: #dc322f; }
      .color_blue { color: #268bd2; }
      .color_green { color: #859901; }
      .color_yellow { color: #b58901; }
      .color_black { color: black; }
      .color_white { color: white; }

      .font_big {
        font-size: 1.2em;
      }

      .ddoc_section_h {
        font-weight: bold;
        font-size: 13px;
        line-height: 19.5px;
        margin-top: 11px;
        display: block;
      }

      body.dlang .dlang {
        display: inline-block;
      }

      body.dlang .declaration .dlang {
          display: block;
      }

      body.dlang .ddoc_header_anchor a.dlang {
        display: block;
        color: rgba(0, 136, 204, 1);
        text-decoration: none;
      }

      body.dlang .ddoc_header_anchor .code {
        color: rgba(0, 136, 204, 1);
      }

      #ddoc_main .module {
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-style: none solid solid;
          border-width: 0 1px 1px;
          overflow-x: hidden;
          padding: 15px;
      }

      #ddoc_main .section .section {
        margin-top: 0;
      }

      #ddoc_main .ddoc_module_members_section {
          padding: 1px 0 0;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members section.intro {
          background: #fff none repeat scroll 0 0;
          list-style-type: none;
          width: 100%;
      }

      #ddoc_main .ddoc_header_anchor {
          font-size: 1.4em;
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .ddoc_header_anchor > .code {
          display: inline-block;

      }

      #ddoc_main .ddoc_decl {
        background-color: transparent;
        height: 100%;
        left: 0;
        top: 0;
        padding: 0;
        padding-left: 15px;
      }

      #ddoc_main .ddoc_decl .section, #ddoc_main .section.ddoc_sections {
        background: white none repeat scroll 0 0;
        margin: 0;
        padding: 5px;
        position: relative;
        border-radius: 5px;
      }

      #ddoc_main .ddoc_decl .section h4:first-of-type, #ddoc_main .section.ddoc_sections h4:first-of-type {
        font-size: 13px;
        line-height: 1.5;
        margin-top: 21px;
      }

      #ddoc_main .section .declaration {
          margin-top: 21px;
      }

      #ddoc_main .section .declaration .code {
          color: rgba(0, 0, 0, 1);
          margin-bottom: 15px;
          padding-bottom: 6px;
      }

      #ddoc_main .declaration div .para {
          margin-bottom: 0;
      }

      #ddoc_main .ddoc_params .graybox tr td:first-of-type {
        padding: 7px;
        text-align: right;
        vertical-align: top;
        word-break: normal;
        white-space: nowrap;
      }

      #ddoc_main .ddoc_params .graybox {
        border: 0 none;
      }

      #ddoc_main .ddoc_params .graybox td {
        border-color: rgba(214, 214, 214, 1);
      }

      #ddoc_main .ddoc_params .graybox tr:first-child > td {
        border-top: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr:last-child > td {
        border-bottom: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:first-child {
        border-left: 0 none;
      }

      #ddoc_main .ddoc_params .graybox tr > td:last-child {
        border-right: 0 none;
        width: 100%;
      }

      #ddoc_main em.term, #ddoc_main em.term .code {
        color: rgba(65, 65, 65, 1);
        font-size: 12px;
        font-style: italic;
        line-height: 1.5;
      }

      #ddoc_main .see-also {
        cursor: pointer;
        font-family: Menlo,monospace;
      }

      #ddoc_main .ddoc_decl .section > div:last-of-type {
        margin-bottom: 15px;
      }

      #ddoc_main .ddoc_member, #ddoc_main .ddoc_module_members {
          transition: transform 0.3s ease 0s;
      }

      #ddoc_main .code_sample {
        background: inherit;
      }

      #ddoc_main .declaration .code-line {
          display: block;
          font: 1em Menlo,monospace;
      }

      #ddoc_main a[name] {
        margin: -112px 0 0;
        padding-top: 112px;
      }

      #ddoc_main .ddoc_decl td {
        max-width: inherit;
      }

      #ddoc_main .declaration a {
        color: inherit;
      }

      #ddoc_main .declaration a:hover {
          color: rgba(0, 136, 204, 1);
          text-decoration: underline;
      }

      body.ddoc {
        background-color: transparent;
        color: rgba(0, 0, 0, 1);
        font-family: Helvetica,Arial,sans-serif;
        font-size: 62.5%;
        margin: 0;
        border: 0;
        left: 0;
        top: 0;
        padding: 0;
      }

      .ddoc a[name] {
        display: block;
        height: 0;
        margin: -85px 0 0;
        padding-top: 85px;
        width: 0;
      }

      .ddoc .module {
          border-color: transparent;
          background-color: rgba(255, 255, 255, 1);
          border-color: currentColor rgba(233, 233, 233, 1) rgba(233, 233, 233, 1);
          border-image: none;
          border-style: none solid solid;
          border-width: 0 1px 1px;
          box-shadow: 0 0 1px rgba(0, 0, 0, 0.07);
          display: block;
          margin-left: 0;
          min-height: calc(100% - 173px);
          overflow: auto;
          padding-bottom: 100px;
      }

      .ddoc .content_wrapper {
          background-color: rgba(242, 242, 242, 1);
          margin: 0 auto;
          max-width: 980px;
      }

      .ddoc .section {
        padding: 15px 25px 30px;
      }

      .ddoc .section .section {
        margin: 30px 0 0;
        padding: 0;
      }

      .ddoc .para {
        color: rgba(65, 65, 65, 1);
        font-size: 1.4em;
        line-height: 145%;
        margin-bottom: 15px;
      }

      .ddoc .ddoc_examples .para {
        margin-bottom: 0;
      }

      .ddoc .module_name {
          color: rgba(0, 0, 0, 1);
          display: block;
          font-family: Helvetica;
          font-size: 2.8em;
          font-weight: 100;
          margin-bottom: 0;
          padding: 15px 0;
      }

      .ddoc .module a {
          color: rgba(0, 136, 204, 1);
          text-decoration: none;
      }

      .ddoc .code {
        color: rgba(128, 128, 128, 1);
        font-family: Menlo,monospace;
        font-size: 0.85em;
        word-wrap: break-word;
      }

      .ddoc .code i {
        font-style: normal;
      }

      .ddoc .code .code {
        font-size: 1em;
      }

      .ddoc .code_sample {
        background-clip: padding-box;
        margin: 1px 0;
        text-align: left;
      }

      .ddoc .code_sample {
        display: block;
        font-size: 1.4em;
        margin-left: 21px;
      }

      .ddoc ol .code_sample {
        font-size: 1em;
      }

      .ddoc .code_lines {
        counter-reset: li;
        line-height: 1.6em;
        list-style: outside none none;
        margin: 0;
        padding: 0;
      }

      .ddoc .code_listing .code_sample div {
        margin-left: 13px;
        width: 93%;
      }

      .ddoc .code_listing .code_sample div .code_lines li {
        list-style-type: none;
        margin: 0;
        padding-right: 10px;
      }

      .ddoc .code_sample div .code_lines li::before {
        margin-left: -33px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+10)::before {
        margin-left: -39px;
        margin-right: 25px;
      }

      .ddoc .code_sample div .code_lines li:nth-child(n+100)::before {
        margin-left: -46px;
        margin-right: 25px;
      }

      .ddoc .code_sample .code_lines .code {
        color: #000;
      }

      .ddoc div.dlang {
        margin: 10px 0 21px;
        padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
          margin: 10px 0 21px;
          padding: 4px 0 2px 10px;
      }

      .ddoc div.dlang {
        border-left: 5px solid rgba(0, 155, 51, 0.2);
      }

      .ddoc .code_lines li::before {
        color: rgba(128, 128, 128, 1);
        content: counter(li, decimal);
        counter-increment: li;
        font-family: Menlo,monospace;
        font-size: 0.9em;
        margin-right: 16px;
      }

      .ddoc .code_lines li {
        padding-left: 0;
        white-space: pre-wrap;
      }

      .ddoc .code_lines li:only-of-type::before {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:only-of-type {
        color: rgba(255, 255, 255, 1);
        content: " ";
      }

      .ddoc .code_lines li:nth-child(n+10) {
        text-indent: -17px;
      }

      .ddoc .code_lines li:nth-child(n+10)::before {
        margin-right: 12px;
      }

      .ddoc .graybox {
        border: 1px solid rgba(233, 233, 233, 1);
        border-collapse: collapse;
        border-spacing: 0;
        empty-cells: hide;
        margin: 20px 0 36px;
        text-align: left;
      }

      .ddoc .graybox p {
        margin: 0;
        min-width: 50px;
      }

      .ddoc th {
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: bottom;
      }

      .ddoc td {
        border: 1px solid rgba(233, 233, 233, 1);
        margin: 0;
        max-width: 260px;
        padding: 5px 10px 5px 10px;
        vertical-align: middle;
      }

      .punctuation {
        color: rgba(0, 0, 0, 1);
      }

      .comment {
        color: rgba(0, 131, 18, 1);
      }

      .operator {
        color: #000;
      }

      .keyword {
        color: rgba(170, 13, 145, 1);
      }

      .keyword_type {
        color: rgba(170, 51, 145, 1);
      }

      .string_literal {
        color: rgba(196, 26, 22, 1);
      }

      .ddoc_psuper_symbol {
        color: rgba(92, 38, 153, 1);
      }

      .param {
        color: rgba(0, 0, 0, 1);
      }

      .psymbol {
        color: rgba(0, 0, 0, 1);
      }

      .ddoc_member_header .ddoc_header_anchor .code {
        font-size: 1em;
      }
    </style>
  </head>
  <body id="ddoc_main" class="ddoc dlang">
    <div class="content_wrapper">
      <article class="module">
        <h1 class="module_name">buffer</h1>
        <section id="module_content">
<section class="section ddoc_module_members_section">
  <div class="ddoc_module_members">
    <ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#StaticBuffer" id="StaticBuffer"><code class="code">StaticBuffer</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="StaticBuffer"></span>struct <code class="code">StaticBuffer</code>(InternalType = char);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Dynamic buffer with a maximum length of one memory page which can take up to <a href="#StaticBuffer.max">max</a> elements.
 Takes an advantage of the system's memory mirroring capabillities to
 create a memory loop so that memory copying wont be necessary.
 The buffer may be manipulated normally as if it were a T[].

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">Note:</span>

<ol><li>Setting the buffer to anything else than memory that the buffer owns will cause memory leaks and exceptions.</li>
<li><b style="color:blue;">[WINDOWS]</b> Only one instance of this type, or any type that creates a file in memory, is allowed.</li>
</ol>

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">T</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Element type which the buffer will hold. Defaults to char.
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>

</section>
<ul class="ddoc_members">
  <li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#StaticBuffer.opCall" id="StaticBuffer.opCall"><code class="code">opCall</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="StaticBuffer.opCall"></span>static nothrow @nogc @trusted typeof(this) <code class="code">opCall</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    
<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">import</span> buffer, source;

<span class="keyword">scope</span> bufchar = StaticBuffer!()(); <span class="comment">// Create buffer, defaults to char[]
</span><span class="keyword">assert</span>(bufchar == <span class="string_literal">""</span>);

<span class="keyword">scope</span> StaticBuffer!<span class="keyword">int</span> bufint = StaticBuffer!<span class="keyword">int</span>(); <span class="comment">// Create buffer of int[]
</span><span class="keyword">assert</span>(bufint == []);

<span class="comment">// With fill, internally calls constructor and then fill()
</span>
<span class="keyword">scope</span> StaticBuffer!<span class="keyword">char</span> fakebufchar = <span class="string_literal">"Hello World!"</span>;
<span class="keyword">assert</span>(fakebufchar.avail == fakebufchar.max - <span class="string_literal">"Hello World!"</span>.length);

<span class="keyword">scope</span> StaticBuffer!<span class="keyword">int</span> fakebufint = [1,2,3,4,5];
<span class="keyword">assert</span>(fakebufint.avail == fakebufint.max - ([1,2,3,4,5]).length);		

<span class="keyword">scope</span> StaticBuffer!<span class="keyword">char</span> fakebufcharlong = StaticBuffer!<span class="keyword">char</span>(<span class="string_literal">"Hello World!"</span>);
<span class="keyword">assert</span>(fakebufcharlong.avail == fakebufcharlong.max - <span class="string_literal">"Hello World!"</span>.length);

<span class="keyword">scope</span> StaticBuffer!<span class="keyword">int</span> fakebufintlong = StaticBuffer!<span class="keyword">int</span>([1,2,3,4,5]);
<span class="keyword">assert</span>(fakebufintlong.avail == fakebufintlong.max - ([1,2,3,4,5]).length);
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#StaticBuffer.max" id="StaticBuffer.max"><code class="code">max</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="StaticBuffer.max"></span>enum auto <code class="code">max</code>;

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns the maximum size of the buffer depending on the size of T.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#StaticBuffer.avail" id="StaticBuffer.avail"><code class="code">avail</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="StaticBuffer.avail"></span>nothrow @nogc @trusted size_t <code class="code">avail</code>();

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Returns how many T's of free buffer space is available.
  </p>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#StaticBuffer.fill" id="StaticBuffer.fill"><code class="code">fill</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="StaticBuffer.fill"></span>void <code class="code">fill</code>(bool isSafe = false, ArrayType)(scope const ArrayType <code class="code">arr</code>) if (!types.isSource!ArrayType &amp;&amp; __traits(compiles, <code class="code">arr</code>[$]) &amp;&amp; is(typeof(<code class="code">arr</code>[0]) : T));

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
     Extends the buffer with new data directly from an array or buffer masquerading as an array.
 In this variant of <code class="code">fill</code>, consuming the source is not needed nor is returning lifetime.
 The following must be <code class="code">true</code> on function call:

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="keyword">assert</span>(buffer.avail &gt;= array.length);
</code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">isSafe</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Safety guarantee optimization, set to <code class="code">true</code> if pop count after last unsafe <code class="code">fill</code> is less than max or less than 2 times max after construction.
 Safety guaranteed calls can be stacked, but a singular call is more efficient. Removes all overhead from the buffer compared to a normal array. <b>Default:</b> <font color=red>False.</font>
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">array</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Array source that is slicable and has a length property.
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>

</section>

</div>

</li><li class="ddoc_member">
  <div class="ddoc_member_header">
  <div class="ddoc_header_anchor">
  <a href="#StaticBuffer.fill" id="StaticBuffer.fill"><code class="code">fill</code></a>
</div>
</div><div class="ddoc_decl">
  <section class="section">
    <div class="declaration">
      <h4>Declaration</h4>
      <div class="dlang">
        <p class="para">
          <code class="code">
            <span class="ddoc_anchor" id="StaticBuffer.fill.2"></span>bool <code class="code">fill</code>(bool isSafe = false, Source)(ref scope Source <code class="code">source</code>) if (types.isSource!Source);

          </code>
        </p>
      </div>
    </div>
  </section>
</div>
<div class="ddoc_decl">
  <section class="section ddoc_sections">
  <div class="ddoc_summary">
  <p class="para">
    Extends the buffer with new data from an abstacted reference <code class="code">source</code>.

  </p>
</div>
<div class="ddoc_params">
  <h4>Parameters</h4>
  <table cellspacing="0" cellpadding="5" border="0" class="graybox">
    <tbody>
      <tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">isSafe</em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Safety guarantee optimization, set to <code class="code">true</code> if pop count after last unsafe <code class="code">fill</code> is less or equal to max or less than 2 times max after construction.
 Safety guaranteed calls can be stacked, but a singular call is more efficient. Removes all overhead from the buffer compared to a normal array. <b>Default:</b> <font color=red>False.</font>
    </p>
  </div>
</td>
</tr>
<tr class="ddoc_param_row">
  <td scope="ddoc_param_id">
  <code class="code">
    <em class="term">Source <code class="code">source</code></em>
  </code>
</td>
<td>
  <div class="ddoc_param_desc">
    <p class="para">
      Object that implements the <font color="blue"><a href="https://cyroxin.github.io/Elembuf/types.html">docs/types</a></font> <code class="code">source</code> interface.
 The function "ptrdiff_t read(void[] arr)" is expected to be implemented, where arr is the free writable area of the buffer.
 It should return the amount of bytes written, otherwise less than or equal to zero.
 For examples on how to implement the read interface, see
 <font color="blue"><a href="https://cyroxin.github.io/Elembuf/source.html">docs/<code class="code">source</code></a></font>
    </p>
  </div>
</td>
</tr>

    </tbody>
  </table>
</div>
<div class="ddoc_returns">
  <h4>Return Value</h4>
  <p class="para">
    
  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">True:</span>
Source is not empty and can be reused.

  </p>
</div>
<div class="ddoc_section">
  <p class="para">
    <span class="ddoc_section_h">False:</span>
Source has been emptied.
  </p>
</div>
<div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    Usage

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">// [BASIC]
</span><span class="keyword">import</span> buffer,<span class="param">source</span>;

StaticBuffer!<span class="keyword">char</span> buf = StaticBuffer!()();

ArraySource!<span class="keyword">char</span> srcworld = ArraySource!<span class="keyword">char</span>(<span class="string_literal">" World!"</span>);
ArraySource!<span class="keyword">char</span> srcbuf = ArraySource!<span class="keyword">char</span>(<span class="string_literal">"buf"</span>);

buf.<span class="psymbol">fill</span>(<span class="string_literal">"Hello"</span>); <span class="comment">// Old method of filling without abstraction
</span><span class="keyword">assert</span>(buf == <span class="string_literal">"Hello"</span>);

buf.<span class="psymbol">fill</span>(srcworld); <span class="comment">// Old method of filling with abstraction
</span><span class="keyword">assert</span>(buf == <span class="string_literal">"Hello World!"</span>);

buf &lt;&lt; <span class="string_literal">" -Elem"</span>; <span class="comment">// Modern way of filling, equivalent to .fill
</span><span class="keyword">assert</span>(buf == <span class="string_literal">"Hello World! -Elem"</span>);

buf &lt;&lt;= srcbuf; <span class="comment">// Modern way of filling, equivalent to .fill!true
</span><span class="keyword">assert</span>(buf == <span class="string_literal">"Hello World! -Elembuf"</span>);

buf.length = 0; <span class="comment">// Remove all items. O(1)
</span><span class="keyword">assert</span>(buf == <span class="string_literal">""</span> &amp;&amp; buf[0..5] == <span class="string_literal">"Hello"</span>); <span class="comment">// Elements are not truly gone until overwritten.
</span>
<span class="keyword">assert</span>((buf &lt;&lt; srcworld) == <span class="keyword">false</span>); <span class="comment">// Source consumed.
</span><span class="keyword">assert</span>((buf &lt;&lt;= srcbuf) == <span class="keyword">false</span>); <span class="comment">// Source consumed.
</span></code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div><div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    Optimization

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">// [INTERMEDIATE]
</span><span class="comment">// Removing all overhead from fill by using compile-time guarantees by counting increments to slice pointer.  
</span>
	<span class="keyword">char</span>[] data(size_t characters) <span class="keyword">pure</span> <span class="keyword">nothrow</span> @trusted
	{
		<span class="keyword">char</span>[] arr;
		arr.reserve(characters);
		arr.length = characters;

		arr[] = ' ';
		<span class="keyword">return</span> arr;
	}

	StaticBuffer!<span class="keyword">char</span> buf = StaticBuffer!()(); <span class="comment">/// There is (max * 2 - 1) of free pops after construction.
</span>
	buf &lt;&lt;= data(buf.max);

	buf = buf[$ .. $]; <span class="comment">// Do work
</span>	<span class="keyword">assert</span>(buf == <span class="string_literal">""</span>);

	<span class="comment">// max - 1 pops left
</span>
	buf &lt;&lt;= data(buf.avail - 1); <span class="comment">// In this case, (avail - 1) == (max - 1)
</span>
	buf = buf[$ .. $]; <span class="comment">// Do work
</span>	<span class="keyword">assert</span>(buf == <span class="string_literal">""</span>);

	<span class="comment">// Out of free pops. Next pop will cause an exception.
</span>
	buf &lt;&lt; data(buf.max); <span class="comment">// Safety is now reinstated by the buffer.
</span>	buf = buf [$..$]; <span class="comment">// Can now pop buf.max times again!
</span>
	<span class="comment">// Repeat from last comment region. Note: Setting length does not add to the pop count.
</span></code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div><div class="ddoc_examples">
  <h4>Examples</h4>
  <p class="para">
    Properties

<section class="code_listing">
  <div class="code_sample">
    <div class="dlang">
      <ol class="code_lines">
        <li><code class="code"><span class="comment">// [ADVANCED]
</span><span class="comment">// This is a example of how to mirror data to create new array item orders using a mirror.
</span><span class="comment">// X will represent data that is viewed by the buffer and O data that is not viewed, but still owned by it.
</span><span class="comment">// | will represent the mirror or page boundary. Left side of | is the first page, right side is the second.
</span>
StaticBuffer!<span class="keyword">char</span> buf = StaticBuffer!()(); <span class="comment">// OO|OO
</span>buf.length = buf.max; <span class="comment">// XX|OO
</span>
buf = buf[buf.max/2..$]; <span class="comment">// OX|OO
</span>buf[] = 'a'; <span class="comment">// Set all in X to 'a'
</span>buf.length = buf.max; <span class="comment">// OX|XO
</span>buf[$/2..$] = 'b'; <span class="comment">// Set all X right side of | to 'b'
</span>
<span class="comment">// The buffer is in a mirror |, half of the buffer is in the first page and half in second page. OX|XO
</span><span class="comment">// It is possible to invert the buffer so, that data starts with 'b' instead of 'a'.
</span><span class="comment">// Data is identical left and right side of the mirror, thus inversion can be sought from the mirror.
</span>
<span class="comment">// a, OX|XO
</span>buf = (buf.ptr - buf.max/2)[0..buf.max]; <span class="comment">// XX|OO
</span><span class="keyword">assert</span>(buf[0] == 'b' &amp;&amp; buf[$/2+1] == 'a'); <span class="comment">// Opt: In this case $ could be buf.max as well.
</span>
<span class="comment">// b, XX|OO
</span>buf = (buf.ptr + buf.max)[0..buf.length]; <span class="comment">// OO|XX
</span><span class="keyword">assert</span>(buf[0] == 'b' &amp;&amp; buf[$/2+1] == 'a'); <span class="comment">// As seen, both sides are identical. Both pages contain a's and b's.
</span></code></li>
      </ol>
    </div>
  </div>
</section>

  </p>
</div>
</section>

</div>

</li>
</ul>

</div>

</li>
</ul>
  </div>
</section>
</section>
      </article>
    </div>
  </body>
</html>
